Jay Rush
1/16/2018 - Sina & Robbie.


1. Who are you and what are you working on?
   1. QuickBlocks works with the Ethereum blockchain from the data side. How does one get usable, fast data out of the blockchain (as opposed to putting into the blockchain with a smart contract for example). Our work is fully decentralized (gets all of its data directly and only from the node); We take a bottom-up approach. We run for particular accounts or groups of account, not necessarily chain-wide. We retrieve and store only what the end user asks for.
1. What are your biggest frustrations?
   1. Biggest concern: The idea of decentralization is being lost
      1. People are developing applications that are highly centralized, because it’s practical. Many projects promise they will one day decentralize, but I’m concerned that this will get increasingly more difficult as the technical debt grows. Many projects are deeply relient on highly centralized infrastructure (Infura, EtherScan).
   1. Concern: The law of unintended consequences:
      1. Identification Systems
         1. Ease of use is very enticing
         2. Blockchain based identity is easily applicable for government use
         3. But...what happens when a “bad-actor” government or an oppressive regime requires citizens to all have unforgeable identity. How will innocent people who are legitimately against the regime hide themselves?
         4. I wrote about this here.
      1. Reputation Systems
         1. If we move to a world where everyone has an immutable reputation--by definition half of the population will always have a worse reputation than the other half. Due to the nature of feedback loops, this feels like a bad idea.
   1. Concern: The data is too difficult to use        
      1. Per Account Lists of Transactions:
         1. Accounting for both incoming and outgoing external transactions is easy. Just scan to and from fields looking for a given address.
         2. Accounting for outgoing message calls (Etherscan calls these internal transactions) is also pretty easy. The smart contract itself initiated the message call -- send an event.
         3. Accounting for incoming internal transactions is very difficult. One must look at every message call generated by the entire system to fully account for all incoming internal transactions (witness air drops). I wrote about this here.
      1. Bloom filters:
         1. Every transaction receipt has a logsBloom field. These are ‘rolled up’ into the block level. Blocks also have a logsBloom field.
         2. As the number of transactions per block increases (as it has done), the block-level bloom filters are getting more and more saturated. As they become more saturated, they will tend to report more false positives.
         3. At the receipt level, the logsBloom are probably under-utilized (that is, they could hold more information without a large increase in false positive rate).
         4. These two factors tend to make the logsBloom field both less effective than it could be and at the same time require more storage than they need to.
         5. I wrote about this here.
         6. Furthermore, the bloom filters exclude certain ‘addresses’ that, if they were included, would allow us to implement an RPC entry point called ‘eth_listAddressesInBlock(bn)’. This would be a compromise between a full index of addresses per block and re-scanning every trace for addresses if one wanted to build a list of transactions per address (which one would want to do if one wanted to audit a smart contract for example).
         7. What QuickBlocks does: Do not store either the block level nore the receipt level blooms from the raw data. Instead, at each block, build an enhanced bloom filter which (1) includes every address involved in the block including those used as ‘data’ for internal transactions (ERC20 transfers and air drops), fill the bloom filters to a predetermined level (configurable, defaults to 200 bits), and when one bloom fills up, create another one at the same block. Result: significantly less storage devoted to blooms, consistent level of false positives resulting in less overall searching, ability to quickly answer ‘is this address used anywhere in this block’ with perfect fidelity.
      1. Inefficiencies
         1. Sept-Oct 2016 DDos transactions make requesting traces astronomically slow. I wrote about this here and here. Suggestion: easier way to identify (and skip over) dDos transactions.
         2. When you use ‘eth_getTransactionByHash’, the RPC does not return the transaction receipt. In order to get the receipt, you must later call ‘eth_getTransactionReceipt’. You need the receipt to understand if the transaction was ended in failure. Twice as many calls to RPC than needed. Suggestion: staple the receipt to the transaction with an optional parameter to eth_getTransaction.
      1. Transaction Error Codes prior to Byzantium Fork:
         1. After the Byzantium Fork, getting the error status of a transaction is easy. If the ‘status’ field of the receipt is zero, then the transaction ended in error [There may be some edge cases here, we are reviewing this claim].
         2. Prior to Byzantium, one had to search every transaction trace looking for a trace that contains the word ‘error’.
         3. If one is doing historical analysis prior to the Byzantium fork, or trying to gather lists of transactions per account, one has to look at every trace.
         4. Core developers seem more focused on what’s happening at the front of the chain (understandably); rather than getting the data out of the chain. Even though getting the data out is as important.
         5. Suggestion: It would be useful to include a status field in pre-byzantium receipts at the option of the caller of the RPC.
      1. The need for ABI definitions
         1. Get Solidity to make the ABI available, because it makes analysis simpler.
         2. Get people to understand the importance of providing ABIs.
1. Other bounties?
   1. The tracing API across the two clients is different and seems ad-hoc.
      1. A common format for the tracing RPC calls, so tools such as QuickBlocks which rely on the traces would be easier to build.
      2. I use Parity. I can’t switch to Geth because they don’t share the same interface for the traces.
1. Other domain specific questions?
   1. QuickBlocks is Ethereum-centric; works on Ethereum derived chains. Not Bitcoin.
   2. Every 15 seconds, QuickBlocks polls for data from the node, it then
      1. Optimizes the data for quick, later retrieval
      2. Optionally, stores the data efficiently
      3. Next time user asks for a block, retrieval is faster (it’s a cache).
   1. How QuickBlocks started:
      1. I wanted my own transactions – for my 40 different Ethereum accounts.
      2. Accounting for movement of funds between all accounts.
      3. Initially – was pulling data from Etherscan. But why do this through a website?
   1. Designed to run on a laptop which forces us to stay decentralized
   2. Applications:
      1. When you develop smart contracts, you get event data from web3. But this only give you generated events. In-error transactions are not seen because they do not generate events
      2. Can analyze tokens.
      3. Can do smart contract monitoring / early warning system
      4. Should write monitoring code which watches blockchain – if it notices something weird, your contract can react. If the DAO had had events in it.
   1. Was involved in the DAO. Stunning how little information was available. It took many hours for anyone to notice the hack because no-one was actively watching
      1. I did some analysis of DAO hack. The actual hack is very obvious in the data on the very first block.
   1. Would appreciate intros and connections to other projects.
   2. The code is ready to go. Will be fully open sourced and properly licensed soon.
   3. QuickBlocks won  2nd place at NYC Consensus 2017 hackathon.
   4. Thomas Rush founded the Philadelphia Ethereum group.
      1. We welcome speakers from around the world -- please contact me if interested
   1. A bounty I would pay for––
      1. Kumavis was talking about blockchain data on IPFS or Swarm or another content-addressable distributed storages.
         1. Could build a blockchain that is a chain of IPFS hashes.
         2. A marketplace of block data could grow.
         3. Infura –– could pull the block data from Infura.
         4. I don’t care about the hexadecimal raw blockchain data – I only want the transaction data fully-parsed – stored on IPFS.
   1. From an email follow-up (possible bounty I might pay for):
      1. For a particular range of blocks (preferably in the millions), and using a given list of Ethereum account addresses (one of which will be an ERC20 token, addresses to be specified in the bounty), provide a definitive list of all internal message calls and external transactions along with, at the end of each block, a reconciliation of each address’ ether balances. Additionally, at the end of each day in the block range, provide a list of token holders along with each token holder's token balances. The source of the data must be provided. Using 3rd party websites (such as Etherscan) is permitted, but the source of the data must be disclosed. Preference is data provided directly from a local Ethereum node.
      2. The given list of address will be interrelated and taken from a prominent ERC20 token system. One of the addresses will be an regular, external account. Another will be an ERC 20 token smart contract. A third will be a multi-sig wallet. The deliverable will be JSON data showing all internal and external transactions for each address. The delivered data must ‘parse’ the transactions to the smart contracts (that is, the transaction’s input data field must be converted from the hexadecimal to “the language of the smart contract”. The deliverable will be a collection of JSON files formatted using a jsonlinter with specific settings which would allow for diffing results with other methods. Performance metrics will be provided as well. The results must be made open source so as to provide the smart contract auditing community with a ‘gold standard’ of community vetted results to be used for testing/verifying new or existing off-chain auditing tools/software.